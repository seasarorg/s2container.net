<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><!-- don't edit start --><title>Seasar - DI Container with AOP -</title><meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="seasar_b.css" type="text/css" rel="stylesheet" media="screen"><link href="seasar_p.css" type="text/css" rel="stylesheet" media="print"><script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script></head>


<body onload="preload('ja')"><table align="left" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr>
<td align="left" valign="top" width="780"><table class="white" border="0" cellpadding="0" cellspacing="0" width="780">
<tbody><tr><td colspan="7"><img src="images/top01_b.gif" alt="" height="5" width="780"></td></tr>
<tr><td width="235"><img src="images/top02_b.gif" alt="Seasar" height="117" width="235"></td>
<td colspan="3"><img src="images/top03.gif" alt="DI Container with AOP" height="117" width="289"></td>
<td colspan="3"><img src="images/spacer.gif" alt="" height="117" width="256"></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td><a href="http://www.seasar.org/index.html"><img src="images/menu01_b_ja.gif" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)" border="0" height="30" width="78"></a></td>
<td><a href="http://www.seasar.org/projects.html"><img src="images/menu02_b_ja.gif" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)" border="0" height="30" width="101"></a></td>

<td><a href="http://www.seasar.org/products.html"><img src="images/menu03_b_ja.gif" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)" border="0" height="30" width="110"></a></td>
<td><a href="http://www.seasar.org/resources.html"><img src="images/menu04_b_ja.gif" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)" border="0" height="30" width="113"></a></td>
<td><img src="images/menu05_b_ja.gif" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)" border="0" height="30" width="109"></td>
<td width="34"><img src="images/menu06.gif" alt="" height="30" width="34"></td></tr><tr>
<td colspan="6"><img src="images/spacer.gif" alt="" height="19" width="545"></td></tr></tbody></table>
<table class="white" border="0" cellpadding="0" cellspacing="0" width="780">
<tbody><tr align="left" valign="top"><td width="18"><img src="images/spacer.gif" alt="" height="14" width="18"></td><td class="main" width="744">
<!-- don't edit end -->
<!-- document start -->

           <ul>
              <li><a href="#S2ContainerReference">S2Container.NET リファレンス</a>
                <ul>
                  <li><a href="#CreateFile">作成すべきファイル</a></li>
                  <li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>

                  <li><a href="#S2ContainerCreation">S2Containerの生成</a></li>
                  <li><a href="#getComponent">コンポーネントの取得</a></li>
                  <li><a href="#AppConfig">アプリケーション構成ファイル</a></li>
                  <li><a href="#DIType">Dependency Injectionのタイプ</a>
                    <ul>
                      <li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
                      <li type="circle"><a href="#PropertyInjection">プロパティ・インジェクション</a></li>

                      <li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
                    </ul>
                  </li>
                  <li><a href="#Include">S2Container定義の分割とインクルード</a></li>
                  <li><a href="#Namespace">名前空間</a></li>
                  <li><a href="#InstanceMode">インスタンス管理</a></li>
                  <li><a href="#Lifecycle">ライフサイクル</a></li>

                  <li><a href="#AutoBindingMode">自動バインディング</a></li>
                  <li><a href="#UseS2Container">コンポーネントでS2Containerを利用する</a></li>
                  <li><a href="#S2HttpModule">S2HttpModule</a></li>
                  <li><a href="#app.dicon">app.diconの役割</a></li>
                  <li><a href="#Aop">AOPの適用</a></li>
				  <li><a href="#Meta">メタデータ</a></li>

				  <li><a href="#Request">Requestの自動バインディング</a></li>
                </ul>
              </li>
              <li><a href="#DefReference">S2Container定義タグリファレンス</a>
                <ul>
                  <li><a href="#DOCTYPE">DOCTYPE</a></li>
                  <li><a href="#componentsTag">componentsタグ</a></li>

                  <li><a href="#includeTag">includeタグ</a></li>
                  <li><a href="#componentTag">componentタグ</a></li>
                  <li><a href="#argTag">argタグ</a></li>
                  <li><a href="#propertyTag">propertyタグ</a></li>
				  <li><a href="#metaTag">metaタグ</a></li>
                  <li><a href="#initMethodTag">initMethodタグ</a></li>

                  <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                  <li><a href="#aspectTag">aspectタグ</a></li>
                  <li><a href="#descriptionTag">descriptionタグ</a></li>
                  <li><a href="#Jscript">JScript.NET式</a></li>
                </ul>
              </li>
              <li><a href="#Example">Example</a>

                <ul>
                  <li><a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a></li>
                  <li><a href="#PropertyInjectionEx">プロパティ・インジェクション</a></li>
                  <li><a href="#MethodInjectionEx">メソッド・インジェクション</a></li>
                  <li><a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a></li>
                  <li><a href="#AutoPropertyInjectionEx">自動バインディング(プロパティ・インジェクション)</a></li>

                </ul>
              </li>
            </ul>

            <a name="S2ContainerReference"><h2>S2Container.NET リファレンス</h2></a>

            <a name="CreateFile"><b><h3>作成すべきファイル</h3></b></a>
            <p>S2Containerを使用するためには、定義ファイルを作成する必要があります。<br/>
            定義ファイルは、コンポーネントを組み立てるための設計書のようなものです。<br/>
            形式はXMLで、拡張子は、diconです。（xmlでも特に問題はありません）diconは、ダイコンと読みます。</p>

            <a name="S2ContainerDefinition"><b><h3>S2Containerの定義</h3></b></a>
            <p>S2Containerの定義は、次のようになります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;

            ...
    &lt;/component&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;

</pre>

            <p>DOCTYPEは省略できません。diconファイルを作成する場合は、上記のサンプルをコピー＆ペーストしてください。ルートは<a href="#componentsTag">componentsタグ</a>です。コンポーネントごとに、<a href="#componentTag">componentタグ</a>を定義していきます。componentタグのclass属性でコンポーネントのクラスの完全限定名を指定します。name属性には、コンポーネント名を指定します。詳細は、<a href="#DefReference">S2Container定義タグリファレンス</a>を参照してください。</p>


<pre>
&lt;components&gt;
    &lt;component name=&quot;hoge&quot; class=&quot;Seasar.Examples.Dicon.HogeImpl&quot;/&gt;

&lt;/components&gt;
</pre>


            <a name="S2ContainerCreation"><h3>S2Containerの生成</h3></a>
            <p>S2Containerを作成する場合は、次のメソッドを使用します。</p>
            <p>- Seasar.Framework.Container.Factory.S2ContainerFactory#Create(string path)</p>
            <p>定義ファイルは、埋め込まれたリソースもしくはファイルシステムで指定することができます。</p>
            <p>埋め込まれたリソースを使用する場合は、引数pathは定義ファイルの名前空間を含む完全限定名です。
            セパレータは、/です。
            定義ファイルのビルドアクションプロパティは、埋め込まれたりソースに設定します。</p>
            <p>C#プロジェクトの場合は、フォルダを作成すると名前空間が作成されます。
            VB.NETプロジェクトの場合は、フォルダを作成しても名前空間は作成されません。
            例えば、プロジェクトフォルダ/Sample/Logic/aaa.diconとすると、C#プロジェクトの場合は、
            既定の名前空間/Sample/Logic/aaa.diconになります。
            VB.NETの場合は、既定の名前空間/aaa.diconになります。</p>
            <p>ファイルシステムを使用する場合は、一般的なファイルパスを指定します。
            絶対パス、相対パスを指定できます。</p>
            <p>埋め込まれたリソース、ファイルシステムの定義ファイルを混在させることもできます。
            同じパスで埋め込まれたリソース、ファイルシステムの両方でヒットする場合は、
            ファイルシステムの定義ファイルが優先されます。</p>

<pre>

private const string PATH = "aaa/bbb/ccc.dicon";
...
IS2Container container = S2ContainerFactory.Create(PATH);
</pre>


            <a name="getComponent">
<h3>コンポーネントの取得</h3></a>
            <p>S2Containerからコンポーネントを取り出すには、次のメソッドを使用します。</p>
            <p>- Seasar.Framework.Container.IS2Container#GetComponent(object componentKey)</p>
            引数には、コンポーネントの型宣言を表すSystem.Typeもしくはコンポーネント名を指定できます。
            詳しくは、<a href="#componentTag">componentタグ</a>を参照してください。
            コンポーネントのクラスを指定する場合、コンポーネント is クラスがtrueを返すクラスなら
            指定することができます。しかし、S2Containerの中に指定したクラスを実装しているコンポーネントが複数ある場合、
            S2Containerは、どのコンポーネントを返せばよいのか判断できないため、
            TooManyRegistrationRuntimeExceptionが発生します。
            実装コンポーネントがユニークに決まるクラスを指定してください。
            コンポーネント名で取得することもできます。その場合も、同一の名前をもつコンポーネントが複数登録されている場合、
            TooManyRegistrationRuntimeExceptionが発生します。コンポーネント名指定の場合、
            スペルミスをする可能性もあるので、できるだけクラス指定のほうが良いでしょう。<br/><br/>

            <p>例） クラスを指定してコンポーネントを取得する場合</p>
<pre>
IS2Container container = S2ContainerFactory.Create(PATH);
Hoge hoge = (Hoge) container.GetComponent(typeof(Hoge));
</pre>

            <p>例） コンポーネント名を指定してコンポーネントを取得する場合</p>
<pre>
IS2Container container = S2ContainerFactory.Create(PATH);
Hoge hoge = (Hoge) container.GetComponent("hoge");
</pre>

<a name="AppConfig"><h3>アプリケーション構成ファイル</h3></a>
<p>
アプリケーション構成ファイル（※diconファイルではありません）に&lt;seasar&gt;構成セクションを追加することができます。
&lt;seasar&gt;構成セクションでは、ルートとなる定義ファイル(diconファイル）、
S2Container作成時にロードするアセンブリを指定することができます。
</p>
<p>
指定された定義ファイルは、Seasar.Framework.Container.Factory.SingletonS2ContainerFactory#Init
が呼び出されたときに、ルートの定義ファイルとしてセットされます。
</p>
<p>
指定されたアセンブリは、Seasar.Framework.Container.Factory.S2ContainerFactory#Create
が呼び出されたときに、アプリケーションドメインに読み込まれます。
</p>
<pre>
&lt;configuration&gt;
   &lt;configSections&gt;
      &lt;section name="seasar"
         type="Seasar.Framework.Xml.S2SectionHandler, Seasar" /&gt;
   &lt;/configSections&gt;

   &lt;seasar&gt;
      &lt;!-- SingletonS2ContainerFactory#Initで下記で指定されたdiconファイルを
           ルートのdiconファイルの初期値としてセットします。 --&gt;
      &lt;configPath&gt;App.dicon&lt;/configPath&gt;
      
      &lt;!-- S2コンテナ作成時に以下で指定されたアセンブリをAppDomainに
           読み込みます。（S2ContainerFactory#Create） --&gt;
      &lt;assemblys&gt;
         &lt;assembly&gt;アセンブリ名1&lt;/assembly&gt;
         &lt;assembly&gt;アセンブリ名2&lt;/assembly&gt;
      &lt;/assemblys&gt;
   &lt;/seasar&gt;

&lt;/configuration&gt;
</pre>

            <a name="DIType"><h3>Dependency Injectionのタイプ</h3></a>

            <p>Dependency Injectionには、コンポーネントの構成に必要な値をコンストラクタで設定する
            (Constructor Injection)のか、プロパティのsetアクセサで設定する(Property Injection)のか、
            初期化メソッドで設定する(Method Injection)のかで、タイプが分かれます。
            Method InjectionはS2のオリジナルです。(S2Container.NETでもサポート）
            S2Container.NETはすべてのタイプとそのハイブリッド型もサポートします。</p>

            <a name="ConstructorInjection"><b><h3>コンストラクタ・インジェクション</h3></b></a>
            <p>コンストラクタ・インジェクションとは、任意のコンストラクタの引数値にDependency Injectionします。
            <br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントは、componentタグで組み立てます。
            class属性でクラス名を指定します。<br/>name属性でコンポーネントに名前を付けることもできます。</li>

            <li><b>コンストラクタの引数の指定</b><br/>コンポーネントのコンストラクタの引数は、
            componentタグの子タグであるargタグを使って指定します。<br/>文字列の場合は、
            ダブルコーテーション(")で囲みます。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;

          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            詳しい使用方法は、Exampleの<a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a>を参照してください。<br/><br/>

            <a name="PropertyInjection"><b><h3>プロパティ･インジェクション</h3></b></a>
            <p>プロパティ･インジェクションとは、任意のプロパティにsetアクセサを使用してProperty Injectionします。<br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>プロパティの指定</b><br/>コンポーネントのプロパティは、componentタグの子タグであるpropertyタグを使って指定します。<br/>name属性でプロパティ名を指定します。</li>

         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;property name=&quot;...&quot;&gt;...&lt;/property&gt;

    &lt;/component&gt;
&lt;/components&gt;
</pre>


            詳しい使用方法は、Exampleの<a href="#PropertyInjectionEx">プロパティ･インジェクション</a>を参照してください。<br/>

            <a name="MethodInjection"><b><h3>メソッド・インジェクション</h3></b></a>

            <p>メソッド・インジェクションとは、任意のメソッドを呼び出して、Dependency Injectionします。
            <br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。
            <br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>初期化メソッドの指定</b><br/>initMethodタグを使って、コンポーネントの任意のメソッドを呼び出します。
            name属性で、メソッド名を指定します。引数は、argタグを子タグに使います。name属性を省略して、
            ボディで、<a href="#JScript">JScript.NET</a>を使うこともできます。
            その際、コンポーネント自身はselfで表します。</li>

         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;initMethod&gt;...&lt;/initMethod&gt;

    &lt;/component&gt;
&lt;/components&gt;
</pre>

            詳しい使用方法は、Exampleの<a href="#MethodInjectionEx">メソッド・インジェクション</a>を参照してください。<br/>

            <a name="Include"><h3>S2Container定義の分割とインクルード</h3></a>
            <p>すべてのコンポーネントを1つのファイルに記述すると、直ぐに肥大化してしまい管理が難しくなります。そのため、コンポーネントの定義を複数に分割する機能と分割された定義をインクルードして1つにまとめる機能がS2Containerにあります。S2Container定義ファイルのインクルードは次のようにして行います。</p>

<pre>&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p><a href="#includeTag">includeタグ</a>のpath属性で取り込みたいS2Container定義ファイルのパスを指定します。詳しくは、<a href="#includeTag">includeタグ</a>を参照してください。<br/>コンポーネントの検索順は、先ず自分自身に登録されているコンポーネントを探して、見つからない場合は、includeされている順に子供のS2Containerに登録されているコンポーネントを検索し、最初に見つかったコンポーネントが返されます。<br/>次のような場合は、Foo(自身のコンポーネント)→aaa(子供のS2Container)→bbb(子供のS2Container)の順に検索します。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;aaa.dicon&quot;/&gt;
    &lt;include path=&quot;bbb.dicon&quot;/&gt;
    &lt;component class=&quot;Examples.Container.Foo&quot; /&gt;

&lt;/components&gt;
</pre>

            <p>自動で<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>や<a href="#PropertyInjection">プロパティ・インジェクション</a>を行う場合、S2Containerはインクルード先のコンポーネントを自動インジェクションすることができます。自動でDependency Injectionを行う場合の条件は<a href="#AutoBindingMode">自動バインディング</a>を参照してください。<br/>次のようにセッター･インジェクションでプロパティに指定するコンポーネントがインクルード先のaaa.diconとbbb.diconに登録されている場合、各HelloClientでは、どちらのコンポーネントが使用されるかをみてましょう。</p>

            <h5>root.dicon</h5>

<pre>
&lt;components&gt;
    &lt;include path=&quot;Seasar.Examples/Reference/Includes/aaa.dicon&quot;/&gt;
    &lt;include path=&quot;Seasar.Examples/Reference/Includes/bbb.dicon&quot;/&gt;
    
    &lt;component name=&quot;root&quot; class=&quot;Seasar.Examples.Reference.Includes.Impl.HelloClientImpl&quot;/&gt;

&lt;/components&gt;
</pre>

            <h5>aaa.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;Seasar.Examples.Reference.Includes.Impl.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Aaa!&quot;&lt;/property&gt;

    &lt;/component&gt;

    &lt;component name=&quot;aaa&quot; class=&quot;Seasar.Examples.Reference.Includes.Impl.HelloClientImpl&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>bbb.dicon</h5>

<pre>
&lt;components&gt;
    &lt;component class=&quot;Seasar.Examples.Reference.Includes.Impl.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Bbb!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;bbb&quot; class=&quot;Seasar.Examples.Reference.Includes.HelloClientImpl&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>各コンポーネントの内容は、次のようになります。</p>

<pre>

namespace Seasar.Examples.Reference.Includes
{
    public interface IHelloClient
    {
        void ShowMessage();
    }
}
</pre>

<pre>
namespace Seasar.Examples.Reference.Includes.Impl
{
    public class HelloClientImpl : IHelloClient
    {
        private IHello hello;

        public HelloClientImpl() {}
        
        public IHello Hello
        {
            get { return this.hello; }
            set { this.hello = value; }
        }

        public void ShowMessage()
        {
            Console.WriteLine(this.Hello.Message);
        }
    }
}
</pre>

<pre>
namespace Seasar.Examples.Reference.Includes
{
    public interface IHello
    {
        string Message
        {
            set;
            get;
        }
    }
}
</pre>

<pre>
namespace Seasar.Examples.Reference.Includes.Impl
{
    public class HelloImpl : IHello
    {
        private string helloMessage;
        
        public HelloImpl() {}

        public string Message
        {
            get { return this.helloMessage; }
            set { this.helloMessage = value; }
        }
    }
}

</pre>

           <p>HelloImplはMessageプロパティを定義しているだけです。HelloClientのShowMessage()を呼び出した場合の実行結果は次のようになります。</p>

           <h5>rootの実行結果</h5>
<pre>
Hello Aaa!
</pre>
           <p>まず、S2Containerはroot.diconにHelloImplが登録されているかを検索します。root.diconにはないので、次にインクルード先のaaa.diconを検索します。
          aaa.diconにはHelloImplが登録されているので、そのコンポーネントを使用します。</p>

           <h5>aaaの実行結果</h5>

<pre>
Hello Aaa!
</pre>

           <p>aaaは、aaa.diconに登録されているコンポーネントを使用します。自動でインジェクションを行う場合、
           子供のS2Containerは親のS2Containerのコンポーネントを使用することはできません。
           例えば、root.diconにHelloImplを登録していてもaaaには自動インジェクションされないということです。</p>

           <h5>bbbの実行結果</h5>
<pre>
Hello Bbb!
</pre>

           <p>aaaと同様にbbbもbbb.diconに登録されているコンポーネントを使用します。
           <br/>このサンプルは、Seasar.ExamplesプロジェクトのS2/NET/Examples/Reference/Includes以下に用意されています。</p>

            <a name="Namespace"><h3>名前空間</h3></a>
            <p>コンポーネントの定義を分割した場合に、複数のコンポーネント定義間で名前が衝突しないように、
            <a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。</p>
            <h5>foo.dicon</h5>
<pre>
&lt;components namespace=&quot;Foo&quot;&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;

    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>bar.dicon</h5>

<pre>
&lt;components namespace=&quot;Bar&quot;&gt;
    &lt;include path=&quot;foo.dicon&quot;/&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;

    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name=&quot;ccc&quot; ...&gt;

        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>app.dicon</h5>

<pre>

&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>同一のコンポーネント定義内では、名前空間なしで参照できます。他のS2Container定義のコンポーネントを参照する場合は、名前空間.をコンポーネント名の頭につけます。foo.aaaとbar.aaaは同じ名前がついていますが、名前空間が異なっているので、違うコンポーネントとして認識されます。慣習として、定義ファイルの名前は、名前空間.diconにすることを推奨します。</p>

<a name="InstanceMode">
<h3>インスタンス管理</h3></a>

            <p>S2Containerで、コンポーネントのインスタンスをどのように管理するのかを指定するのが、
            <a href="#componentTag">componentタグ</a>のinstance属性です。デフォルトはsingletonで、
            これは、IS2Container.GetComponent()によって返されるコンポーネントは常に同じだという意味です。
            IS2Container.GetComponent()を呼び出すたびに、新たに作成されたコンポーネントを返して欲しい場合は、instance属性にprototypeを指定します。
            リクエスト(System.Web.HttpRequest)ごとにコンポーネントを管理したい場合は、instance属性にrequestを指定します。
            セッション(System.Web.SessionState.HttpSessionState)ごとにコンポーネントを管理したい場合は、instance属性にsessionを指定します。</p>
            <p>プレゼンテーションのフレームワークと組み合わせるときに、プレゼンテーションフレームワークが作成したインスタンスに対して、
            S2Containerで管理されているコンポーネントをセットしたい場合があります。
            そのようなS2Container外のコンポーネントに対して
            <a href="http://www.kakutani.com/trans/fowler/injection.html">Dependency Injection</a>したいときには、次のメソッドを使用します。
            <br/><br/>- Seasar.Framework.Container.IS2Container#InjectDependency(Object outerComponent)
            <br/>- Seasar.Framework.Container.IS2Container#InjectDependency(Object outerComponent, Type componentType)
            <br/>- Seasar.Framework.Container.IS2Container#InjectDependency(Object outerComponent, string componentName)</p>
            第一引数には、外部のコンポーネントを指定します。第二引数には、外部コンポーネントのクラス、またはコンポーネント名を指定します。
            <br/>そのとき、S2Container定義では、instance属性にouterを指定します。

<table width="744" border="1">

  <tr bgcolor="#d1f3f4" align="center">
    <th width="104" scope="col">instance属性</th>
    <th width="624" scope="col">説明</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>IS2Container.GetComponent()を何度呼び出しても同じインスタンスが返されます。</td>

  </tr>
  <tr>
    <td>prototype</td>
    <td>IS2Container.GetComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
  </tr>
  <tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがリクエストに格納されます。
requestを使う場合は、<a href="#request">S2HttpModule</a>を設定する必要があります。</td>

</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがセッションに格納されます。sessionを使う場合は、<a href="#request">S2HttpModule</a>を設定する必要があります。</td>
</tr>
<tr>
  <td>outer</td>
  <td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>

</tr>
</table>

            <a name="Lifecycle"><h3>ライフサイクル</h3></a>
<p>initMethodやdestroyMethodでコンポーネントのライフサイクルもコンテナで管理することができます。
S2Containerの開始時(S2Container.Init())に<a href="#initMethodTag">initMethodタグ</a>で指定したメソッドが呼び出され、
S2Containerの終了時(S2Container.Destroy())に<a href="#destroyMethodTag">destroyMethodタグ</a>
で指定したメソッドが呼び出されるようになります。initMethodはコンポーネントがコンテナに登録した順番に実行され、
destroyMethodはその逆順に呼び出されることになります。instance属性がsingleton以外の場合、destroyMethodを指定しても無視されます。
System.Collections.Hashtable#Add()メソッドに初期化(aaaに111を設定)・終了処理(aaaにnullを設定)を設定する場合は、次のようになります。</p>
<pre>
&lt;components namespace=&quot;bar&quot;&gt;

    &lt;component name=&quot;table&quot; class=&quot;System.Collections.Hashtable&quot;&gt;
        &lt;initMethod name=&quot;Add&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;Add&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <a name="AutoBindingMode"><h3>自動バインディング</h3></a>
            <p>コンポーネント間の依存関係は、型がインターフェースの場合、コンテナによって自動的に解決されます。これがS2Containerのデフォルトですが、<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。</p>

<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>

<p>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合、引数のないデフォルトコンストラクタが定義されている場合はそのコンストラクタを使います。<br/>

デフォルトのコンストラクタがない場合、コンストラクタの引数の数が1以上で、引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いものを使います。<br/>
プロパティが明示的に指定されている場合はそれに従います。<br/>
明示的に指定されていないプロパティで、型がインターフェースの場合は自動的にバインドします。</p>
</td>
</tr>
<tr>
<td>constructor</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合、引数のないデフォルトコンストラクタが定義されている場合はそのコンストラクタを使います。<br/>
デフォルトのコンストラクタがない場合、コンストラクタの引数の数が1以上で、引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いものを使います。<br/>

プロパティが明示的に指定されている場合は、それに従います。</td>
</tr>
<tr>
<td>property</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合は、デフォルトのコンストラクタを使います。<br/>
型がインターフェースのプロパティを自動的にバインドします。</td>
</tr>
<tr>
<td>none</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>

プロパティが明示的に指定されている場合はそれに従います。</td>
</tr>
</table>
            <br/>

            <p>詳しくは、<a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a>と<a href="#AutoPropertyInjectionEx">自動バインディング(プロパティ・インジェクション)</a>を参照してください。</p>

            <a name="UseS2Container"><h3>コンポーネントでS2Containerを利用する</h3></a>

            <p>コンポーネントはS2Containerに依存しないことが望ましいのですが、コンポーネントによっては、
            S2Containerのメソッドを呼び出したい場合もあるでしょう。S2Container自身もcontainerという名前で、
            登録されているので、arg,propertyタグのボディでcontainerを指定することで、コンテナのインスタンスを取得できます。
            また、S2Container型のプロパティを定義しておいて自動バインディングで設定することもできます。
            arg,propertyタグでcontainerを指定する場合は、次のようになります。</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;Examples.Dicon.BarImpl&quot;&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class=&quot;Examples.Dicon.FooImpl&quot;&gt;
        &lt;property name=&quot;Foo&quot;&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <a name="S2HttpModule"><h3>S2HttpModule</h3></a>
<p>これまでは、.NET Frameworkアプリケーションで、明示的にS2Containerを作成していましたが、
Webアプリケーションの場合、誰がS2Containerを作成するのでしょうか。その目的のために次のクラスが用意されています。</p>
<p>- Seasar.Framework.Container.Web.S2HttpModule</p>
S2HttpModuleを使うためには、Web.configに次の項目を記述します。<br/>
source/Seasar/Seasar.Framework.Container/Web/Web.configに記述例もあります。

<pre>
    &lt;httpModules&gt;
	 &lt;add name="S2HttpModule"
	     type="Seasar.Framework.Container.Web.S2HttpModule, Seasar" /&gt;
    &lt;/httpModules&gt;
</pre>

<p><a href="#AppConfig">アプリケーション構成ファイル</a>に定義するseasarセクションのconfigPath要素で
メインとなるS2Container定義のパスを指定します。S2HttpModuleが起動した後は、
次のメソッドでS2Containerのインスタンスを取得することができます。</p>
<p>- Seasar.Framework.Container.Factory.SingletonS2ContainerFactory#GetContainer()</p>

<p>S2HttpModuleを使っている場合、HttpApplicationをhttpApplicationという名前のコンポーネントとして
アクセスできるようになります。</p>

<a name="app.dicon"><h3>app.diconの役割</h3></a>
<p>すべてのS2Container定義のルートになる定義ファイルは、慣例でapp.diconという名前にします。app.diconにはコンポーネントの定義はしないようにしてください。
通常は名前空間の付かない場所に埋め込まれたリソースとして配置しておくと良いでしょう。</p>

<pre>
&lt;components&gt;

    &lt;include path=&quot;Examples/foo.dicon&quot;/&gt;
    &lt;include path=&quot;Examples/bar.dicon&quot;/&gt;
         &lt;!-- 定義ファイルの数分記述します --&gt;
&lt;/components&gt;
</pre>

<a name="Aop"><h3>AOPの適用</h3></a>
<p>コンポーネントに<a href="aop.html">AOP</a>を適用することもできます。
ただし現在のS2Container.NETではAOPを適用するには、System.MarshalByRefObjectの派生クラスであるか、
インターフェース型でコンポーネントを受け取る必要があります。
例えば、ArrayListに<a href="aop.html#TraceInterceptor">TraceInterceptor</a>を適用したい場合次のようにします。</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;traceInterceptor&quot;
               class=&quot;Seasar.Framework.Aop.Interceptors.TraceInterceptor&quot;/&gt;
               
    &lt;component class=&quot;System.Collections.ArrayList&quot;&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;

    &lt;component class=&quot;TestSeasar.Framework.Container.Factory.AspectTagHandlerTest+FooImpl&quot;&gt;
        &lt;aspect pointcut=&quot;Time, GetHashCode&quot;&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;

&lt;/components&gt;
</pre>

<p>aspectタグのボディで<a href="aop.html#Advice">Interceptor</a>の名前を指定します。
pointcut属性にカンマ区切りで対象となるメソッド名・プロパティ名を指定することができます。
pointcut属性を指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。
メソッド名には正規表現(System.Text.RegularExpressions.Regex)も使えます。この定義を使うサンプルは次のようになります。</p>

<pre>
private const string PATH = "Framework/Container/Factory/AspectTagHandlerTest.dicon";

[Test]
public void TestAspect()
{
    IS2Container container = S2ContainerFactory.Create(PATH);
			
    IList list = (IList) container.GetComponent(typeof(IList));
    int count = list.Count;

    IFoo foo = (IFoo) container.GetComponent(typeof(IFoo));
    int time = foo.Time;
    foo.ToString();
    int hashCode = foo.GetHashCode();
}

public interface IFoo
{
    int Time { get; }
    int GetHashCode();
    string ToString();
}

public class FooImpl : IFoo
{
    private int time_ = 3;

    public FooImpl()
    {
    }

    #region IFoo メンバ

    public int Time
        {
            get
            {
                return time_;
            }
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return time_.ToString();
        }

        #endregion
    }

</pre>

            <p>実行結果は次のようになります。</p>

<pre>
BEGIN System.Collections.ICollection#get_Count()
END System.Collections.ICollection#get_Count() : 0
BEGIN Seasar.Tests.Framework.Container.Factory.AspectTagHandlerTest+IFoo#get_Time()
END Seasar.Tests.Framework.Container.Factory.AspectTagHandlerTest+IFoo#get_Time() : 3
BEGIN Seasar.Tests.Framework.Container.Factory.AspectTagHandlerTest+IFoo#GetHashCode()
END Seasar.Tests.Framework.Container.Factory.AspectTagHandlerTest+IFoo#GetHashCode() : 1168
</pre>

<a name="Meta">
<h3>メタデータ</h3>
</a>
<p>components、component、arg、propertyタグにメタデータ<a href="aop.html"></a>を指定することもできます。
metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。</p>

<pre>&lt;components&gt;
    &lt;meta name=&quot;aaa&quot;&gt;111&lt;/meta&gt;
&lt;/components&gt;	
</pre>
<p>components、component、arg、propertyタグに指定したメタデータの情報は、IS2Container、IComponentDef、IArgDef、
IPropertyDefで定義されている次のメソッドで取得することが出来ます。</p>
<ul>
<li>public int MetaDefSize</li>
<li>public IMetaDef GetMetaDef(int index)</li>
<li>public IMetaDef GetMetaDef(string name)</li>
<li>public IMetaDef[] GetMetaDefs(string name)</li>
</ul>

<a name="request">

<h3>リクエストの自動バインディング</h3>
</a>
<p>コンポーネントに対して、HttpRequestを自動的にバインディングすることが出来ます。
そのためには、コンポーネントに、HttpRequest Request { set; }のプロパティを定義します。
そうすると、S2Containerが自動的にリクエストを設定します。
また、<a href="#S2HttpModule">S2HttpModule</a>をWeb.configに定義する必要があります。</p>

<p>同様にHttpServletResponse、HttpSessionもプロパティ（setアクセサ）を定義するだけで、自動バインディングすることが出来ます。
また、S2HttpModuleを使うと、HttpRequest、HttpResponse、HttpSessionState、HttpApplicationをそれぞれrequest、
response、session、httpApplicationという名前のコンポーネントとしてアクセスできるようになります。</p>
<a name="DefReference">
<h2>S2Container定義タグリファレンス</h2></a>

<a name="DOCTYPE"><h3>DOCTYPE</h3></a>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot;
            class=&quot;Seasar.Examples.Reference.Injection.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
    
    &lt;component name="ConstructorInjection"
            class="Seasar.Examples.Reference.Injection.HelloConstructorInjectionClient" /&gt;
&lt;/components&gt;
</pre>

            <a name="componentsTag"><h3>componentsタグ(必須)</h3></a>
            <p>ルートのタグになります。</p>
            <a name="namespaceAttr"><h4>namespace属性(任意)</h4></a>
            <p><a href="#Namespace">名前空間</a>を指定することができます。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components namespace=&quot;hoge&quot;&gt;

    ...
&lt;/components&gt;
</pre>

            <a name="includeTag"><h3>includeタグ(任意)</h3></a>
            <p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
            <a name="pathAttr"><h4>path属性(必須)</h4></a>

            <p>定義ファイルのパスを指定することができます。
            定義ファイルのパスには、埋め込まれたリソースもしくはファイルシステムで指定することができます。
埋め込まれたリソースを使用する場合は、定義ファイルの名前空間を含む完全限定名です。 
セパレータは、/です。 定義ファイルのビルドアクションプロパティは、埋め込まれたりソースに設定します。

C#プロジェクトの場合は、フォルダを作成すると名前空間が作成されます。 
VB.NETプロジェクトの場合は、フォルダを作成しても名前空間は作成されません。
 例えば、プロジェクトフォルダ/Sample/Logic/aaa.diconとすると、C#プロジェクトの場合は、 
 既定の名前空間/Sample/Logic/aaa.diconになります。 VB.NETの場合は、既定の名前空間/aaa.diconになります。
ファイルシステムを使用する場合は、一般的なファイルパスを指定します。 絶対パス、相対パスを指定できます。
埋め込まれたリソース、ファイルシステムの定義ファイルを混在させることもできます。
 同じパスで埋め込まれたリソース、ファイルシステムの両方でヒットする場合は、 ファイルシステムの定義ファイルが優先されます。
componentタグの前に記述する必要があります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;

&lt;components&gt;
    &lt;include path=&quot;aaa/bbb/ccc.dicon&quot; /&gt;
&lt;/components&gt;
</pre>

            <a name="componentTag"><h3>componentタグ(任意)</h3></a>
            <p>コンポーネントを定義します。</p>

            <a name="classAttr"><h4>class属性(任意)</h4></a>
            <p>クラスの完全限定名を指定します。ボディで、<a href="#Jscript">JScript.NET式</a>を使って
            コンポーネントを指定した場合は、class属性を省略することができます。
           JScript.NET式を使った場合にclass属性を指定すると、型チェックを行います。</p>
            <a name="componentTag.nameAttr"><h4>name属性(任意)</h4></a>
            <p>名前を指定することもできます。.NETの識別子として使えるものにします。詳しくは、
            <a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
            <a name="instanceAttr"><h4>instance属性(任意)</h4></a>

            <p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
            <a name="autoBindingAttr"><h4>autoBinding属性(任意)</h4></a>
            <p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <a name="argTag"><h3>argタグ(任意)</h3></a>

            <p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。
            記述した順番でコンストラクタに渡されます。
            <a href="#initMethodTag">initMethodタグ</a>、
            <a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。
            記述した順番でメソッドに渡されます。
            引数として渡される実際の値は、ボディで、<a href="#Jscript">JScript.NET式</a>を使うか、子タグで、
            <a href="#componentTag">componentタグ</a>を使います。</p>

            <a name="propertyTag"><h3>propertyタグ(任意)</h3></a>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、
            ボディで、<a href="#Jscript">JScript.NET式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <a name="propertyTag.nameAttr"><h4>name属性(必須)</h4></a>
            <p>プロパティ名を指定します。</p>

			<a name="metaTag"><h3>metaタグ(任意)</h3></a>
            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#Jscript">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <a name="propertyTag.nameAttr">
<h4>name属性(任意)</h4>
</a>
            <p>メタ名を指定します。</p>

            <a name="initMethodTag"><h3>initMethodタグ(任意)</h3></a>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。
            引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、
            <a href="#Jscript">JScript.NET式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。
            initMethodタグが定義されているコンポーネント自身を表すself、Console.Outを表すout、
            Console.Errorを表すerrがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>

            <a name="initMethodTag.nameAttr"><h4>name属性(任意)</h4></a>
            <p>メソッド名を指定します。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;

&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;System.Collections.Hashtable&quot;&gt;
        &lt;initMethod name=&quot;Add&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        
        &lt;initMethod&gt;self.Add(&quot;aaa&quot;, 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;out.WriteLine(&quot;Hello&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <a name="destroyMethodTag"><h3>destroyMethodタグ(任意)</h3></a>
            <p>initMethodタグと同様です。</p>

            <a name="aspectTag"><h3>aspectタグ(任意)</h3></a>

            <p>アスペクトをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#aspectTag">aspectタグ</a>の説明を参照してください。</p>

            <a name="descriptionTag"><h3>descriptionタグ(任意)</h3></a>

            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>

            <a name="Jscript"><h3>JScript.NET式</h3></a>
            <p>S2Container.NETでは、式言語として<a href="http://www.gotdotnet.com/japan/team/jscript/">JScript.NET</a>を利用しています。
            定義ファイルの中で、文字列で記述した内容(式)を.NETのオブジェクトに変換することが出来ます。</p>

            <ul>
            <li>文字列は、&quot;hoge&quot;のように&quot;で囲みます。</li>

            <li>charは、'a'のように'で囲みます。</li>
            <li>数値は、123のようにそのまま記述します。</li>
            <li>論理値は、true,falseのようにそのまま記述します。</li>
            <li>new DateTime()のように標準ライブラリ(mscorlib.dll)のクラスや構造体のコンストラクタを呼び出すことができます。(名前空間のSystemは省略して呼び出します）</li>
            </ul>
            詳しくは、<a href="http://www.microsoft.com/japan/msdn/library/default.asp?url=/japan/msdn/library/ja/jscript7/html/jslrfJScriptLanguageReference.asp">JScript.NETのマニュアル</a>を参照してください。<br/>
            <br/>

            <a name="Example"><h2>Example</h2></a>
            <p>以下のサンプルを実行する場合は、<a href="setup.html">セットアップ</a>を行う必要があります。
            Seasar.ExamplesプロジェクトはWindowsアプリケーションとして作成されています。
            Seasar.Examplesプロジェクトをスタートアッププロジェクトに設定しF5キーを押して開始すると、
            ExamplesExplorerが起動しExampleのソースコードと実行結果を確認することができます。</p>

            <a name="ConstructorInjectionEx"><h3>コンストラクタ・インジェクション</h3></a>
            <p>コンストラクタ・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>
            <li type="circle">インターフェース(IHello.cs)</li>
            <li type="circle">実装クラス(HelloConstructorInjection.cs)</li>
            <li type="circle">diconファイル(HelloConstructorInjection.dicon)</li>

            <li type="circle">実行クラス(HelloConstructorInjection.cs中のHelloconstructorInjectionClientクラス)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">ShowMessage()を定義します。</li>
        </ul>
            <p>先ず最初はインターフェースを考えます。インターフェースと実装を分離することで、
            コンポーネントの利用者は、インターフェースを知っていれば実装のことは知らなくても済むようになります。
            また、テストの時には実装をモックに置き換えることで簡単にテストできるようになります。</p>

<pre>
namespace Seasar.Examples.Reference.Injection
{
    public interface IHello
    {
        void ShowMessage();
    }
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">引数がstring型のコンストラクタを定義します。</li>
            <li type="circle">ShowMessage()を実装します。</li>

        </ul>
            <p>次はいよいよ実装です。コンストラクタでメッセージを受け取り、
            ShowMessage()で受け取ったメッセージを出力します。</p>

<pre>
using System;
namespace Seasar.Examples.Reference.Injection
{
    public class HelloConstructorInjection : IHello
    {
        private string message;

        public HelloConstructorInjection(string message)
        {
            this.message = message;
        }

        public void ShowMessage()
        {
            Console.WriteLine(this.message);
        }
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle"><a href="#componentTag">componentタグ</a>でコンポーネントを定義します。</li>

            <li type="circle">componentタグの子タグの<a href="#argTag">argタグ</a>でコンストラクタの引数値を定義します。</li>
        </ul>

             <p>メッセージをコンポーネントに設定するのは、S2Containerの仕事です。
             定義ファイルに基づいてコンポーネントを組み立てます。<br/><br/>
             Seasar.Examples/Reference/Injection/HelloConstructorInjection.dicon</p>


<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component name="hello"
            class="Seasar.Examples.Reference.Injection.HelloConstructorInjection"&gt;
        &lt;arg&gt;"Hello World!"&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component name="ConstructorInjection"
        class="Seasar.Examples.Reference.Injection.HelloConstructorInjectionClient" /&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.Create(String path)を呼び出してS2Containerを作成します</a>。</li>

            <li type="circle">GetComponent()を使用して、
            <a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
using System;

using Seasar.Framework.Container;
using Seasar.Framework.Container.Factory;

namespace Seasar.Examples.Reference.Injection
{
    public class HelloConstructorInjectionClient
    {
        private static readonly String PATH = 
            "Seasar.Examples/Reference/Injection/HelloConstructorInjection.dicon";

        public void Main() 
        {
            // 型を指定してコンポーネントを取得する場合
            IS2Container container = S2ContainerFactory.Create(PATH);
            IHello hello = (IHello) container.GetComponent(typeof(IHello));
            hello.ShowMessage();

            // 名前を指定してコンポーネントを取得する場合
            IHello hello2 = (IHello) container.GetComponent("hello");
            hello2.ShowMessage();
        }
    }
}
</pre>

            <h5>実行結果</h5>
            <p>argタグで指定した文字列が正しく表示されていることが確認できます。</p>
<pre>
Hello World!
Hello World!
</pre>
            <p>この演習は、Seasar.ExamplesプロジェクトのSeasar.Examples/Reference/Injection以下に用意されています。</p>

            <a name="PropertyInjectionEx"><h3>プロパティ・インジェクション</h3></a>

            <p>プロパティ・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>
            <li type="circle">インターフェース(IHello.cs)（コンストラクタ・インジェクションと同じもの）</li>
            <li type="circle">実装クラス(HelloPropertyInjection.cs)</li>
            <li type="circle">diconファイル(HelloPropertyInjection.dicon)</li>
            <li type="circle">実行クラス(HelloPropertyInjection.cs中のHelloPropertyInjectionClientクラス)</li>

        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">ShowMessage()を定義します。</li>
        </ul>
            <p>インターフェースはコンストラクタ・インジェクションの場合と同じです。
            プロパティに対するgetアクセサ、setアクセサを定義する必要はありません。
            なぜなら、Dependency Injectionするのにコンストラクタを使うのかsetアクセサを使うのかは実装の問題だからです。 </p>

<pre>
namespace Seasar.Examples.Reference.Injection
{
    public interface IHello
    {
        void ShowMessage();
    }
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">プロパティを定義します。</li>
            <li type="circle">ShowMessage()を実装します。</li>
        </ul>

            <p>次は実装です。プロパティ・メソッドでメッセージを受け取り、ShowMessage()で受け取ったメッセージを出力します。</p>

<pre>
using System;

namespace Seasar.Examples.Reference.Injection
{
    public class HelloPropertyInjection : IHello
    {
        private string message;

        public HelloPropertyInjection() {}
		
        public string Message
        {
            get { return this.message; }
            set { this.message = value; }
        }

        public void ShowMessage()
        {
            Console.WriteLine(this.message);
        }
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle">componentタグでコンポーネントを定義します。</li>

            <li type="circle">componentタグの子タグの<a href="#propertyTag">propertyタグ</a>でコンポーネントのプロパティ値を定義します。</li>
        </ul>

           <p>Seasar.Examples/Reference/Injection/HelloPropertyInjection.dicon</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;Seasar.Examples.Reference.Injection.HelloPropertyInjection&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello World!&quot;&lt;/property&gt;
    &lt;/component&gt;
    
    &lt;component name="PropertyInjection" 
        class="Seasar.Examples.Reference.Injection.HelloPropertyInjectionClient" /&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle">S2ContainerFactory.Create(string path)を呼び出してS2Containerを作成します。</li>
            <li type="circle">GetComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>

            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
using System;

using Seasar.Framework.Container;
using Seasar.Framework.Container.Factory;

namespace Seasar.Examples.Reference.Injection
{
    public class HelloPropertyInjectionClient
    {
        private static readonly String PATH =
            "Seasar.Examples/Reference/Injection/HelloPropertyInjection.dicon";

        public void Main() 
        {
            IS2Container container = S2ContainerFactory.Create(PATH);
            IHello hello = (IHello) container.GetComponent(typeof(IHello));
            hello.ShowMessage();
        }
    }
}
</pre>

            <h5>実行結果</h5>
            <p>propertyタグで指定した文字列が正しく表示されていることが確認できます。</p>

<pre>
Hello World!
</pre>

            <p>この演習は、Seasar.ExamplesプロジェクトのSeasar.Examples/Reference/Injection以下に用意されています。</p>

            <a name="MethodInjectionEx"><h3>メソッド・インジェクション</h3></a>
            <p>メソッド・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>

            <li type="circle">インターフェース(IHello.cs)</li>
            <li type="circle">実装クラス(HelloMethodInjection.cs)</li>
            <li type="circle">diconファイル(HelloMethodInjection.dicon)</li>
            <li type="circle">実行クラス(HelloMethodInjection.cs中のHelloMethodInjectionClientクラス)</li>
        </ul>

            <h5>インターフェースの作成</h5>

        <ul>
            <li type="circle">ShowMessage()を定義します。</li>
        </ul>
            <p>追加のメソッドを複数回呼び出すようなケースが代表的な使い方ですが、
            今回の演習では、インターフェースはコンストラクタ・インジェクションの場合と同じにしました。 </p>

<pre>
namespace Seasar.Examples.Reference.Injection
{
    public interface IHello
    {
        void ShowMessage();
    }
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">AddMessage()を定義します。</li>
            <li type="circle">ShowMessage()を実装します。</li>
        </ul>
             <p>次は実装です。AddMessage(string message)でメッセージを複数回追加して、
             ShowMessage()で受け取ったメッセージを出力します。</p>

<pre>
using System;
using System.Text;

namespace Seasar.Examples.Reference.Injection
{
    public class HelloMethodInjection : IHello
    {
        private StringBuilder builder = new StringBuilder();

        public HelloMethodInjection() {}
		
        public void AddMessage(string message)
        {
            this.builder.Append(message);
        }

        public void ShowMessage()
        {
            Console.WriteLine(this.builder.ToString());
        }
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle">componentタグでコンポーネントを定義します。</li>
            <li type="circle">componentタグの子タグの<a href="#initMethodTag">initMethodタグ</a>でコンポーネントのメソッドの引数値を定義します。</li>
        </ul>


            <p>先ずは、argタグを使ってAddMessage(string message)に&quot;Hello &quot;を指定します。
            <br/>次にJScript.NET式を使ってAddMessage(string message)に&quot;World！&quot;を指定します。
            <br/><br/>Seasar.Examples/Reference/Injection/HelloMethodInjection.dicon</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR2.1//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components21.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;Seasar.Examples.Reference.Injection.HelloMethodInjection&quot;&gt;
        &lt;initMethod name=&quot;AddMessage&quot;&gt;
            &lt;arg&gt;&quot;Hello &quot;&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;self.AddMessage(&quot;World!&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
    
    &lt;component name="MethodInjection" 
        class="Seasar.Examples.Reference.Injection.HelloMethodInjectionClient" /&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle">S2ContainerFactory.Create(string path)を呼び出してS2Containerを作成します。</li>
            <li type="circle">GetComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
using System;

using Seasar.Framework.Container;
using Seasar.Framework.Container.Factory;

namespace Seasar.Examples.Reference.Injection
{
    public class HelloMethodInjectionClient
    {
        private static readonly String PATH = 
            "Seasar.Examples/Reference/Injection/HelloMethodInjection.dicon";

        public void Main() 
        {
            IS2Container container = S2ContainerFactory.Create(PATH);
            IHello hello = (IHello) container.GetComponent(typeof(IHello));
            hello.ShowMessage();
        }
    }
}
</pre>

            <h5>実行結果</h5>
            <p>initMethodタグで指定した文字列が正しく表示されていることが確認できます。</p>
<pre>
Hello World!
</pre>
            <p>この演習は、Seasar.ExamplesプロジェクトのSeasar.Examples/Reference/Injection以下に用意されています。</p>


            <a name="AutoConstructorInjectionEx"><h3>自動バインディング(コンストラクタ・インジェクション)</h3></a>
            <p>自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。</p>
        <ul>
            <li type="circle">インターフェース(IHello.cs)</li>
            <li type="circle">インターフェースの実装クラス(AutoHelloConstructorInjection.cs)</li>
            <li type="circle">diconファイル(AutoHelloConstructorInjection.dicon)</li>

            <li type="circle">実行クラス(AutoHelloConstructorInjection.cs中のAutoHelloConstructorInjectionClientクラス)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">ShowMessage()を定義します。</li>
        </ul>

<pre>
namespace Seasar.Examples.Reference.AutoBinding
{
    public interface IHello
    {
        void ShowMessage();
    }
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">引数がIDictionaryのコンストラクタを定義します。</li>
            <li type="circle">ShowMessage()を実装します。</li>
        </ul>

            <p>コンストラクタでIDictionaryを受け取り、
            ShowMessage()でhelloをキーとしてIDictionaryから値を取得して出力します。</p>

<pre>
using System;
using System.Collections;

namespace Seasar.Examples.Reference.AutoBinding
{
    public class AutoHelloConstructorInjection : IHello
    {
        private IDictionary dictionary;

        public AutoHelloConstructorInjection(IDictionary dictionary)
        {
            this.dictionary = dictionary;
        }

        public void ShowMessage()
        {
            Console.WriteLine(dictionary["hello"]);
        }
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle">
<a href="#componentTag">componentタグ</a>でSystem.Collections.IDictionaryの実装クラスである
System.Collections.Hashtableをコンポーネント定義します。</li>

<li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>で
Hashtableにキーとして"hello"、値として"Hello World!"を定義します。</li>
<li type="circle">componentタグでAutoHelloConstructorInjectionをコンポーネント定義します。
autoBinding属性にautoを指定します。<br/>演習であるため auto を明示的に指定していますが、
autoBinding属性のデフォルト値であるため本来は省略します。</li>
        </ul>

             <p>AutoHelloConstructorInjectionには、argタグが定義されていないことに注目してください。
             コンストラクタ・インジェクションを行う場合、argタグを定義する必要がありますが、
             S2Container内にIDictionaryの実装クラスが登録されていれば、
             S2Containerがコンテナ内を検索して自動的に引数を設定します。
             ただし、引数の型がインターフェースでない場合、自動バインディングはできません。
             <br/><br/>Seasar.Examples/Reference/AutoBinding/AutoHelloConstructorInjection.dicon</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;

    &lt;component class="System.Collections.Hashtable"&gt;
        &lt;initMethod name="Add"&gt;
            &lt;arg&gt;"hello"&lt;/arg&gt;
            &lt;arg&gt;"Hello World!"&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component name="hello" autoBinding="auto"
      class="Seasar.Examples.Reference.AutoBinding.AutoHelloConstructorInjection" /&gt;
	
    &lt;component name="AutoConstructorInjection" 
      class="Seasar.Examples.Reference.AutoBinding.AutoHelloConstructorInjectionClient" /&gt;

&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
<li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.Create(string path)
を呼び出してS2Containerを作成します</a>。</li>
            <li type="circle">GetComponent()を使用して、
            <a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>

        </ul>

<pre>
using System;
using Seasar.Framework.Container;
using Seasar.Framework.Container.Factory;
namespace Seasar.Examples.Reference.AutoBinding
{
    public class AutoHelloConstructorInjectionClient
    {
        private static readonly String PATH =
            "Seasar.Examples/Reference/AutoBinding/AutoHelloConstructorInjection.dicon";

        public void Main() 
        {
            IS2Container container = S2ContainerFactory.Create(PATH);
            IHello hello = (IHello) container.GetComponent(typeof(IHello));
            hello.ShowMessage();
        }
    }
}
</pre>

            <h5>実行結果</h5>
            <p>Hashtableの値が表示されていることから、自動的にコンストラクタの引数を設定していることが確認できます。</p>
<pre>
Hello World!
</pre>
            <p>この演習は、Seasar.ExamplesプロジェクトのSeasar.Examples/Reference/AutoBinding以下に用意されています。</p>

            <a name="AutoPropertyInjectionEx"><h3>自動バインディング(プロパティ・インジェクション)</h3></a>
            <p>自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。</p>
        <ul>
            <li type="circle">インターフェース(IHello.cs)</li>
            <li type="circle">インターフェースの実装クラス(AutoHelloPropertyInjection.cs)</li>

            <li type="circle">diconファイル(AutoHelloPropertyInjection.dicon)</li>
            <li type="circle">実行クラス(AutoHelloPropertyInjection.cs中のAutoHelloPropertyInjectionClientクラス)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">ShowMessage()を定義します。</li>

        </ul>

<pre>
namespace Seasar.Examples.Reference.AutoBinding
{
    public interface IHello
    {
        void ShowMessage();
    }
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">IDictionary型のプロパティを定義します。</li>
            <li type="circle">ShowMessage()を実装します。</li>

        </ul>
            <p>IDictionary MessageのsetアクセサでIDictionaryを受け取り、
            ShowMessage()でhelloをキーとしてIDictionaryから値を取得して出力します。</p>

<pre>
using System;
using System.Collections;

namespace Seasar.Examples.Reference.AutoBinding
{
    public class AutoHelloPropertyInjection : IHello
    {
        private IDictionary dictionary;

        public AutoHelloPropertyInjection()
        {
        }
        
        public IDictionary Message
        {
            set { dictionary = value; }
        }

        public void ShowMessage()
        {
            Console.WriteLine(dictionary["hello"]);
        }
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle"><a href="#componentTag">componentタグ</a>でSystem.Collections.IDictionaryの実装クラスであるSystem.Collections.Hashtableをコンポーネント定義します。</li>

            <li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>でHashtableにキーとして"hello"、値として"Hello World!"を定義します。</li>
            <li type="circle">componentタグでAutoHelloPropertyInjectionをコンポーネント定義します。
            autoBinding属性にautoを指定します。<br/>演習であるため auto を明示的に指定していますが、
            autoBinding属性のデフォルト値であるため本来は省略します。</li>
        </ul>

             <p>AutoHelloPropertyInjectionには、propertyタグが定義されていないことに注目してください。
             プロパティ・インジェクションを行う場合、propertyタグで任意のプロパティを定義する必要がありますが、
             S2Container内にIDictionaryの実装クラスが登録されていれば、
             S2Containerがコンテナ内を検索して自動的にプロパティを設定します。ただし、
             プロパティの型がインターフェースでない場合、自動バインディングはできません。
             <br/><br/>Seasar.Examples/Reference/AutoBinding/AutoHelloPropertyInjection.dicon</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;

    &lt;component class="System.Collections.Hashtable"&gt;
        &lt;initMethod name="Add"&gt;
            &lt;arg&gt;"hello"&lt;/arg&gt;
            &lt;arg&gt;"Hello World!"&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component name="hello" autoBinding="auto"
      class="Seasar.Examples.Reference.AutoBinding.AutoHelloPropertyInjection" /&gt;
	
    &lt;component name="AutoPropertyInjection" 
      class="Seasar.Examples.Reference.AutoBinding.AutoHelloPropertyInjectionClient" /&gt;

&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.Create(string path)を呼び出してS2Containerを作成します</a>。</li>
            <li type="circle">GetComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>

        </ul>

<pre>
using System;
using Seasar.Framework.Container;
using Seasar.Framework.Container.Factory;
namespace Seasar.Examples.Reference.AutoBinding
{
    public class AutoHelloPropertyInjectionClient
    {
        private static readonly String PATH =
            "Seasar.Examples/Reference/AutoBinding/AutoHelloPropertyInjection.dicon";

        public void Main() 
        {
            IS2Container container = S2ContainerFactory.Create(PATH);
            IHello hello = (IHello) container.GetComponent(typeof(IHello));
            hello.ShowMessage();
        }
    }
}
</pre>

            <h5>実行結果</h5>
            <p>Hashtableの値が表示されていることから、自動的にプロパティを設定していることが確認できます。</p>
<pre>
Hello World!
</pre>

            <p>この演習は、Seasar.ExamplesプロジェクトのSeasar.Examples/Reference/AutoBinding以下に用意されています。</p>

            <br/>
            <br/>



<!-- document end -->
<!-- don't edit start -->
</td>
<td width="14"><img src="images/spacer.gif" alt="" height="14" width="14"></td>
</tr><tr>
<td width="14"><img src="images/spacer.gif" alt="" height="30" width="14"></td>
<td width="766"><img src="images/spacer.gif" alt="" height="30" width="592"></td>
</tr><tr>
<td width="14"><img src="images/spacer.gif" alt="" height="14" width="14"></td>
<td class="copyright" width="766">&#169; Copyright The Seasar Project and the others 2004-2005, all rights reserved.</td>

</tr></tbody></table>
</td><td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left" height="16" valign="top" width="780">&nbsp;</td>
<td class="backcorner" align="left" height="16" valign="top">&nbsp;</td>
</tr></tbody></table><!-- don't edit end -->
</body></html>
